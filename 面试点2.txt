call 和 apply 的区别是什么，哪个性能更好一些
    作用是一样的，区别在于传入参数的不同
    第一个参数都是指定函数体内 this 的指向；第二个参数开始不同，apply第二个参数是数组或者类数组，call的参数是不固定的
    call的性能比apply要好，call的参数是函数所需的格式

redux 为什么要把 reducer 设计成纯函数
    redux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处都是纯函数。

箭头函数与普通函数（function）的区别是什么？
构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？
    箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：
    1.函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象
    2.不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替；
    3.不可以使用 new 命令，因为：
            没有自己的 this，无法调用 call、apply；
            没有 prototype 属性，而 new 命令在执行时需要将钩子函数的 prototype 赋值给新的对象的 __proto__

Git-Rebase
    可以合并多次提交记录，减少无用的提交信息；
    合并分支并且减少 commit 记录；

简述懒加载
    懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。
    懒加载的原理：首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在 data-original 属性中，当页面滚动的时候需要去监听 scroll 事件，在 scroll 事件的回调中，判断我们的懒加载的图片是否进入可视区域，
    如果图片在可视区内则将图片的 src 属性设置为 data-original 的值，这样就可以实现延迟加载。

webpack 中 loader 和 plugin 的区别是什么？
loader：loader 是一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程；

plugin：plugin 是一个扩展器，，针对是 loader 结束后，webpack 打包的整个过程，
它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行任务。

HTTP1.0 和 HTTP1.1 有什么区别？
    1.缓存处理：在 HTTP1.0 使用Expires 来作为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

    2.带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，而且不支持断点续传功能，HTTP1.1 则在请求头中引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

    3.错误通知的管理：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict） 表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器的某个资源被永久性的删除；

    4.Host 头处理：在 HTTP1.0 中认为每台服务器都绑定唯一的 IP 地址，因此，请求信息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们可以共享一个 IP 地址。HTTP1.1 的请求信息和响应信息都应支持 Host 头域，且请求信息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

    5.长连接：HTTP1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，
    在 HTTP1.1 中默认开启 Connection: keep-alive，
     HTTP1.0 每次请求都要创建连接的缺点。

介绍 HTTPS 握手过程
    1.客户端使用 https 的 url 访问 web 服务器，要求与服务器建立 ssl 连接；
    2.web 服务器收到客户端请求后，会将网站的证书（包含公钥）传送一份给客户端；
    3.客户端收到网站证书后有没有问题，如果没有问题就随机产生一个秘钥；
    4.客户端利用公钥将会话秘钥加密，并传送给服务端，服务端利用自己的私钥解密出会话秘钥；
    5.之后服务器与客户端使用秘钥加密传输；

说出几个你知道的 HTTP 状态码及其功能
    100~199: 信息提示

    200~299：成功

    300~399：重定向

    400~499：客户端错误

    500~599：服务端错误

    200 成功
    204 无内容
    301 永久移动（回应 GET 响应时会自动将请求者转到新位置）
    304 未修改（协商缓存）
    400 Bad Request
    401 未授权
    403 服务器拒绝请求
    404 未找到
    409 请求发生冲突
    500 服务器内部错误
    502 错误网关
    503 服务不可用


    什么是 CDN 服务？
        CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，
        向用户提供资源就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，
        由 CDN 服务器将请求定位到最近的含有该资源的服务器上去请求。
        这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。

    简述你了解的设计模式及应用场景
        1.Observer 模式：
        模式定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。
        应用场景：Redux 实现。
        2.创建对象的工厂模式
        3.发布订阅模式

    介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景
        观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知。
        一对多时使用观察者模式，多对多时使用订阅-发布模式。


    简述前端性能优化
        页面内容方面
            通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况；
            通过 DNS 缓存等机制来减少 DNS 的查询次数；
            通过设置缓存策略，对常用不变的资源进行缓存；
            通过延迟加载的方式，来减少页面首屏加载时需要请求的资源，延迟加载的资源当用户需要访问时，再去请求加载；
            通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度；
        服务器方面
            使用 CDN 服务，来提高用户对于资源请求时的响应速度；
            服务器端自用 Gzip、Deflate 等方式对于传输的资源进行压缩，减少传输文件的体积；
            尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie；


简述 HTTP2.0 与 HTTP1.1 相较于之前版本的改进
    HTTP2.0：
        HTTP2.0 基本单位为二进制，以往是采用文本形式，健壮性不是很好，现在采用二进制格式，更方便更健壮。
        HTTP2.0 的多路复用，把多个请求当做多个流，请求响应数据分成多个帧，不同流中的帧交错发送，
        解决了 TCP 连接数量多，TCP 连接慢，所以对于同一个域名只用创建一个连接就可以了。
        HTTP2.0 压缩消息头，避免了重复请求头的传输，又减少了传输的大小；
        HTTP2.0 服务端推送，浏览器发送请求后，服务端会主动发送与这个请求相关的资源，之后浏览器就不用再次发送后续的请求了；
        HTTP2.0 可以设置请求优先级，可以按照优先级来解决阻塞的问题；

内存泄露原因：
    全局变量：全局变量挂在 root 对象上，不会被清除掉；
    闭包：如果闭包未释放，就会导致内存泄露；
    事件监听：对同一个事件重复监听，忘记移除（removeListener），将造成内存泄露。
解决方案：
    最容易出现也是最难排查的就是事件监听造成的内存泄露，所以事件监听这块需要格外注意小心使用。
    如果出现了内存泄露问题，需要检测内存使用情况，对内存泄露的位置进行定位，然后对对应的内存泄露代码进行修复。




介绍下重绘和回流（Repaint & Reflow），以及如何进行优化？
    浏览器渲染机制：浏览器采用流式布局模型
    浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM,DOM 和 CSSOM 合并就产生了渲染树，
    有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上；
    
    重绘：节点的集合属性发生改变或者由于样式改变而不会影响布局的，称为重绘，例如 outline、visibility、color、background-color 等
    回流：回流是布局或者几何属性需要改变就称为回流
    回流必定会发生重绘，重绘不一定会引发回流。

减少重绘和回流
    1.css： 
        使用 transform 代替 top；
        使用 visibility 替换 display: none，前者引起重绘，后者引发回流；
        避免使用 table 布局；
    2.Javascript
        避免频繁操作样式，修改 class 最好；
        避免频繁操作 DOM，合并多次修改为一次；
        避免频繁读取会引发回流/重绘的属性，将结果缓存；
        对具有复杂动画的元素使用绝对定位，使它脱离文档流；
类的修饰
    修饰器本质就是编译时执行的函数。
    修饰器函数的第一个参数，就是所要修饰的目标类。
    function testable(target) {
  target.isTestable = true;
}

@testable
class MyTestableClass {}


上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable
修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。


前端安全方面问题：
    XSS(cross-site scripting 跨域脚本攻击)，是向网站 A 注入 JS代码，然后执行 JS 里的代码，
        防范：1.编码：对敏感字符进行转义 2.HttpOnly 防止劫取 Cookie
    
    
    CSRF(Cross Site Request Forgery)跨站请求伪造，是利用网站A本身的漏洞，去请求网站A的api。
        防范：1.同源检测（Origin 和 Referer 验证） 2.Token验证